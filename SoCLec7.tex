\documentclass[12pt]{article}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{array}
\usepackage{amssymb}
\usepackage{units}
\usepackage{graphicx}
\usepackage{tikz-cd}
\usepackage{nicefrac}
\usepackage{hyperref}
\usepackage{bbm}
\usepackage{color}
\usepackage{tensor}
\usepackage{tipa}
\usepackage{bussproofs}
\usepackage{ stmaryrd }
\usepackage{ textcomp }
\usepackage{leftidx}
\usepackage{afterpage}
\usepackage{varwidth}
\usepackage{tasks}
\usepackage{ cmll }
\usepackage{makecell}
\usepackage{MnSymbol}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{xparse}
\usepackage{calc}
\usepackage{stackengine}
\usepackage{csquotes}

\newcommand\blankpage{
	\null
	\thispagestyle{empty}
	\addtocounter{page}{-1}
	\newpage
}

\newcommand{\PhantC}{\phantom{\colon}}%
\newcommand{\PhantSQ}{\phantom{\sqrt{\hspace{0.3ex}}}}

% https://tex.stackexchange.com/questions/63355/wrapping-cmidrule-in-a-macro
\ExplSyntaxOn
\makeatletter
\newcommand{\CMidRule}{\noalign\bgroup\@CMidRule{}}
\NewDocumentCommand{\@CMidRule}{
	m % Material to reinsert before cmidrule.
	O{0.0ex} % #1 = left adjust
	O{0.0ex} % #1 = right adjust
	m  %       #3 = columns to span
}{
	\peek_meaning_remove_ignore_spaces:NTF \CMidRule
	{ \@CMidRule { #1 \cmidrule[\cmidrulewidth](l{#2}r{#3}){#4} } }
	{ \egroup #1 \cmidrule[\cmidrulewidth](l{#2}r{#3}){#4} }
}
\makeatother
\ExplSyntaxOff

\graphicspath{ {images/} }

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[subsection] % reset theorem numbering for each chapter
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{fact}[thm]{Fact}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition} % definition numbers are dependent on theorem numbers
\newtheorem{exmp}[thm]{Example} % same for example numbers
\newtheorem{notation}[thm]{Notation}
\newtheorem{remark}[thm]{Remark}
\newtheorem{condition}[thm]{Condition}
\newtheorem{question}[thm]{Question}
\newtheorem{construction}[thm]{Construction}
\newtheorem{exercise}[thm]{Exercise}
\newtheorem{example}[thm]{Example}
\newtheorem{aside}[thm]{Aside}
\newtheorem{algorithm}[thm]{Algorithm}

\def\doubleunderline#1{\underline{\underline{#1}}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\scr}[1]{\mathscr{#1}}
\newcommand{\call}[1]{\mathcal{#1}}
\newcommand{\psheaf}{\text{\underline{Set}}^{\scr{C}^{\text{op}}}}
\newcommand{\und}[1]{\underline{\hspace{#1 cm}}}
\newcommand{\adj}[1]{\text{\textopencorner}{#1}\text{\textcorner}}
\newcommand{\comment}[1]{}
\newcommand{\lto}{\longrightarrow}
\newcommand{\rone}{(\operatorname{R}\bold{1})}
\newcommand{\lone}{(\operatorname{L}\bold{1})}
\newcommand{\rimp}{(\operatorname{R} \multimap)}
\newcommand{\limp}{(\operatorname{L} \multimap)}
\newcommand{\rtensor}{(\operatorname{R}\otimes)}
\newcommand{\ltensor}{(\operatorname{L}\otimes)}
\newcommand{\rtrue}{(\operatorname{R}\top)}
\newcommand{\rwith}{(\operatorname{R}\&)}
\newcommand{\lwithleft}{(\operatorname{L}\&)_{\operatorname{left}}}
\newcommand{\lwithright}{(\operatorname{L}\&)_{\operatorname{right}}}
\newcommand{\rplusleft}{(\operatorname{R}\oplus)_{\operatorname{left}}}
\newcommand{\rplusright}{(\operatorname{R}\oplus)_{\operatorname{right}}}
\newcommand{\lplus}{(\operatorname{L}\oplus)}
\newcommand{\prom}{(\operatorname{prom})}
\newcommand{\ctr}{(\operatorname{ctr})}
\newcommand{\der}{(\operatorname{der})}
\newcommand{\weak}{(\operatorname{weak})}
\newcommand{\exi}{(\operatorname{exists})}
\newcommand{\fa}{(\operatorname{for\text{ }all})}
\newcommand{\ex}{(\operatorname{ex})}
\newcommand{\cut}{(\operatorname{cut})}
\newcommand{\ax}{(\operatorname{ax})}
\newcommand{\negation}{\sim}
\newcommand{\true}{\top}
\newcommand{\false}{\bot}
\DeclareRobustCommand{\diamondtimes}{%
	\mathbin{\text{\rotatebox[origin=c]{45}{$\boxplus$}}}%
}
\newcommand{\tagarray}{\mbox{}\refstepcounter{equation}$(\theequation)$}
\newcommand{\startproof}[1]{
	\AxiomC{#1}
	\noLine
	\UnaryInfC{$\vdots$}
}
\newcommand\showdiv[1]{\overline{\smash{)}#1}}
\newcommand{\set}{\operatorname{\underline{Set}}}
\newcommand{\coherence}[2]{#1\text{ }\rotatebox{90}{()}_A\text{ }#2}



\newenvironment{scprooftree}[1]%
{\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
	{\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }

\title{Because it's there}
\author{William Troiani}
\date{\today}

\begin{document}
	\maketitle
\section{Provenance}

Consider a set $S$. One can define the \textbf{complex vector space freely generated by $S$} $\bb{C}[S]$ in the following way:
\begin{itemize}
	\item The elements of $\bb{C}[S]$ are finite formal sums
	\begin{equation}
		z_1 s_1 + \ldots + z_n s_n
		\end{equation}
	where $n > 0$, $z_i \in \bb{C}$, and $s_i \in S$ for all $i = 1, \ldots, n$.
	\item Scalar multiplication is defined as follows
	\begin{align*}
		\bb{C} \times \bb{C}[S] &\lto \bb{C}[S]\\
		(z,z_1 s_1 + \ldots + z_n s_n) &\longmapsto zz_1 s_1 + \ldots + zz_n s_n
		\end{align*}
	and addition is performed by ``gathering like terms".
	\end{itemize}
This defines a complex vector space. There is an obvious map $S \lto \bb{C}[S]$ and the elements in the image of this map (which we identify with $S$) form a basis for $\bb{C}[S]$. In fact, quite a lot of the structure on $\bb{C}[S]$ is determined by the set $S$. For instance, let $V$ be an arbitrary complex vector space, and consider a morphism $\varphi: \bb{C}[S] \lto V$. By linearity, we have following calculation for an arbitrary vector $z_1 s_1 + \ldots + z_n s_n \in \bb{C}[S]$
\begin{equation}
	\varphi(z_1 s_1 + \ldots + z_n s_n) = z_1 \varphi(s_1) + \ldots + z_n \varphi(s_n)
	\end{equation}
and so $\varphi$ is determined by the set $\varphi(S)$. In other words, if we let $UV$ denote the underlying vector space of $V$, then the map $\varphi$ is determined by its restriction $\varphi\restriction_{S}: S \lto UV$. Moreover, \emph{every} morphism $\bb{C}[S] \lto V$ can be given in this way. So we have:
\begin{proposition}
	For any set $S$ and any complex vector space $V$, there is a bijection:
	\begin{equation}\label{eq:hom_set_adj}
		\operatorname{Hom}_{\bb{C}\operatorname{Vect}}(\bb{C}[S], V) \cong \operatorname{Hom}_{\underline{\operatorname{Set}}}(S, UV)
		\end{equation}
	\end{proposition}
In fact, more can be said. If $f: S \lto T$ is a function of sets, and $\varphi: V \lto W$ a linear transformation, then there exists a pair of commuting diagrams:
\begin{equation}
	\begin{tikzcd}
		\operatorname{Hom}(\bb{C}[S], V)\arrow[r] & \operatorname{Hom}(S, UV)\\
		\operatorname{Hom}(\bb{C}[T], V)\arrow[r]\arrow[u,"{\und{0.2} \circ \bb{C}[f]}"] & \operatorname{Hom}(T, UV)\arrow[u,swap,"{\und{0.2} \circ f}"]
		\end{tikzcd}
	%
	\begin{tikzcd}
		\operatorname{Hom}(\bb{C}[S], V)\arrow[r]\arrow[d,swap,"{\varphi \circ \und{0.2}}"] & \operatorname{Hom}(S, UV)\arrow[d,"{U\varphi \circ \und{0.2}}"]\\
		\operatorname{Hom}(\bb{C}[S], W)\arrow[r] & \operatorname{Hom}(S, UW)
	\end{tikzcd}
	\end{equation}
That is, \eqref{eq:hom_set_adj} is \emph{natural}.

In this discussion we have focussed on vector spaces, but similar constructions exist: the group freely generated by $S$, the monoid freely generated by $S$, the category freely generated by a directed graph, etc. Thus, we make a general definition, \emph{because it's there}.

\begin{defn}
	Let $F: \scr{C} \lto \scr{D}$ and $G: \scr{D} \lto \scr{C}$ be a pair of functors. The functor $F$ is \textbf{left adjoint to $G$} if for all $Y \in \scr{D}$ and all $X \in \scr{C}$ there exists a natural bijection of homsets:
	\begin{align*}
		\operatorname{Hom}_{\scr{C}}(GY, X) \cong \operatorname{Hom}_{\scr{D}}(Y, FX)
		\end{align*}
	We say that $(F,G)$ are an \textbf{adjoint pair} and write $F \dashv G$.
	\end{defn}

\section{Adjunctions}
If we take $\scr{C} = \bb{C}\operatorname{Vect}$, $\scr{D} = \underline{\operatorname{Set}}$, $F = U$ the \textbf{forgetful functor} which maps a vector space to its underlying set and a linear transformation to itself but where we forget the fact that it is linear, and $G = \bb{C}[\und{0.2}]$ the \textbf{free functor} which maps a set $S$ to the complex vector space freely generated by $S$ and a function of sets to its induced linear transformation, then we recover the example given in the introduction and see that the forgetful functor is left adjoint to the free functor.

\begin{example}
	Find a left adjoint to the forgetful functor $U: \underline{\operatorname{Set}}_\ast \lto \underline{\operatorname{Set}}$ which maps a pointed set $(X,x)$ (ie, a set $X$ along with an element $x \in X$) to the set $X$.
	\end{example}

\section{Monads}

An adjunction is a pair of functors $F: \scr{C} \lto \scr{D}, G: \scr{D} \lto \scr{C}$, which means that we have two distinct sides, the side focussed on $\scr{C}$, and the side focussed on $\scr{D}$. What amount of this adjunction is visible on only one side of this adjunction? For instance, the category $\scr{C}$ can ``see" the composite $GF: \scr{C} \lto \scr{C}$. What else? Well, returning to the defining bijection of an adjunction (assuming $F \dashv G$):
\begin{equation}
	\operatorname{Hom}_\scr{D}(FX, Y) \cong \operatorname{Hom}_{\scr{C}}(X, GY)
	\end{equation}
If we put $Y = FX$, then we get
\begin{equation}
	\operatorname{Hom}_\scr{D}(FX, FX) \cong \operatorname{Hom}_{\scr{C}}(X, GFX)
	\end{equation}
where the left hand side has a special element, the identity $\operatorname{id}_{FX}$. The image of this element under the bijection is a special element $\eta_X: X \lto GFX$. In fact, the collection of these fit into a natural transformation
\begin{equation}
	\eta: \operatorname{id}_{\scr{C}} \Rightarrow GF
	\end{equation}
between endofunctors on $\scr{C}$. On the other hand, we could also take $X = GY$ in the above adjunction, and obtain a natural transformation
\begin{equation}
	\epsilon: FG \Rightarrow \operatorname{id}_{\scr{D}}
	\end{equation}
However this is between endofunctors on $\scr{D}$, and so is not visible from the perspective of $\scr{C}$. However, for any $X \in \scr{C}$ we could consider the image under $G$ of the morphism $FGFX$ and obtain a natural transformation
\begin{equation}
	G\epsilon_F: GFGF \Rightarrow GF
	\end{equation}
between a pair of endofunctors on $\scr{C}$. Taking $M = GF$ and $\mu = G\epsilon_F$ we have in summary the following data:
\begin{itemize}
	\item A functor $M$.
	\item A pair of natural transformations.
	\begin{equation}
		\eta: \operatorname{id}_{\scr{C}} \Rightarrow M\qquad \mu: M^2 \Rightarrow M
		\end{equation}
	\end{itemize}
This defines the data of a \textbf{monad} on $\scr{C}$, however this data actually obeys certain axioms due to naturality of the defining bijection involved in an adjunction pair. Once one has done the work involved in unravelling this structure, we arrive at the following, \emph{because it's there}.

\begin{defn}
	A \textbf{monad} is the data of a functor $M: \scr{C} \lto \scr{C}$ along with a pair of natural transformations $\eta: \operatorname{id}_\scr{C} \Rightarrow M, \mu: T^2 \Rightarrow T$ such that the following diagrams commute.
	\begin{equation}
		\begin{tikzcd}
			T^3\arrow[r,"{T\mu}"]\arrow[d,swap,"{\mu_T}"] & T^2\arrow[d,"{\mu}"]\\
			T^2\arrow[r,"\mu"] & T
			\end{tikzcd}
		\begin{tikzcd}
			T\arrow[dr,swap,"{\operatorname{id}}"]\arrow[r, "{T\eta}"] & T^2\arrow[d,"{\mu}"] & T\arrow[l,swap,"{\eta_T}"]\arrow[dl,"{\operatorname{id}}"]\\
			& T
			\end{tikzcd}
		\end{equation}
	\end{defn}

\begin{exercise}[Hard exercise]
	Think about the data of an adjunction pair from the other side of the adjunction to invent the definition of a \emph{comonad}.
	\end{exercise}

\begin{example}
	Let $T: \operatorname{Set} \lto \operatorname{Set}$ act as
	\begin{equation}
		TA = \coprod_{n \geq 0}A^n
		\end{equation}
	Let $\eta_A: A \lto TA$ be defined by $a \longmapsto (a)$, and let $\mu$ be concatination. Then $(T, \eta, \mu)$ is a monad.
	\end{example}

\begin{example}
	Let $T: \operatorname{Set} \lto \operatorname{Set}$ act as
	\begin{equation}
		TA = A \coprod \{ \bot \}
		\end{equation}
	where $\eta_A: A \lto TA$ maps $a \longmapsto a$, and $\mu_A: T^2A \lto TA$ maps both copies of $\bot$ to $\bot$ and acts identically on the remaining elements of $T^2A$.
	\end{example}

Monads are important in mathematics, but they have also been used extensively in computer science. The previous two examples give a hint as to how. They are very helpful for modelling side effects of programs! In functional computer languages where side effects are not possible, the use of monads becomes imperative. Next lecture we will see more precisely how monads have been used both in the mathematical modelling of notions of computation, and also how they have been used practically in the context of a real programming language, Haskell.


\end{document}