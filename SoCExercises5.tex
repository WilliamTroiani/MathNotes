\documentclass[english,letter paper,12pt,leqno]{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{amsmath, amscd, amssymb, mathrsfs, accents, amsfonts,amsthm}
\usepackage[all]{xy}
\xyoption{rotate}
\usepackage{dsfont}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{bbm}
\usepackage{csquotes}
\def\nicedashedcolourscheme{\shadedraw[top color=blue!22, bottom color=blue!22, draw=gray, dashed]}
\def\nicecolourscheme{\shadedraw[top color=blue!22, bottom color=blue!22, draw=white]}
\def\nicepalecolourscheme{\shadedraw[top color=blue!12, bottom color=blue!12, draw=white]}
\def\nicenocolourscheme{\shadedraw[top color=gray!2, bottom color=gray!25, draw=white]}
\def\nicereallynocolourscheme{\shadedraw[top color=white!2, bottom color=white!25, draw=white]}
\definecolor{Myblue}{rgb}{0,0,0.6}
\usepackage[a4paper,colorlinks,citecolor=Myblue,linkcolor=Myblue,urlcolor=Myblue,pdfpagemode=None]{hyperref}
\usepackage[final]{showlabels} % inner

\def\can{\operatorname{can}}
\def\Hom{\operatorname{Hom}}
\def\be{\begin{equation}}
	\def\ee{\end{equation}}
\def\nN{\mathds{N}}
\def\nZ{\mathds{Z}}
\def\nQ{\mathds{Q}}
\def\nR{\mathds{R}}
\def\nC{\mathds{C}}
\def\ldot{\,.\,}
\def\typearrow{\Rightarrow}
\def\FV{\operatorname{FV}}
\def\jac{\operatorname{Jac}_W}
\DeclareMathOperator{\id}{id}
% Commands
\newcommand{\proofvdots}[1]{\overset{\displaystyle #1}{\rvdots}}
\def\Res{\res\!}
\newcommand{\ud}{\mathrm{d}}
\newcommand{\Ress}[1]{\res_{#1}\!}
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\lto}{\longrightarrow}
\newcommand{\xlto}[1]{\stackrel{#1}\lto}
\newcommand{\md}[1]{\mathscr{#1}}
\def\sus{\l}
\def\l{\,|\,}
\def\sgn{\textup{sgn}}
\def\samp{\zeta}
\def\Samp{Z}
\def\traff{N}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\scr}[1]{\mathscr{#1}}

\SelectTips{cm}{}

\setlength{\evensidemargin}{0.1in}
\setlength{\oddsidemargin}{0.1in}
\setlength{\textwidth}{6.3in}
\setlength{\topmargin}{0.0in}
\setlength{\textheight}{8.5in}
\setlength{\headheight}{0in}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{thm}[theorem]{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{setup}[theorem]{Setup}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{question}{Question}

% Labels in tabular
\newcommand{\tagarray}{\mbox{}\refstepcounter{equation}$(\theequation)$}

\newtheoremstyle{example}{\topsep}{\topsep}
{}
{}
{\bfseries}
{.}
{2pt}
{\thmname{#1}\thmnumber{ #2}\thmnote{ #3}}

\theoremstyle{example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{desi}[theorem]{Desiderata}

\numberwithin{equation}{section}

% Will stuff}
\newcommand{\call}[1]{\mathcal{#1}}
\newcommand{\psheaf}{\text{\underline{Set}}^{\scr{C}^{\text{op}}}}
\newcommand{\und}[1]{\underline{\hspace{#1 cm}}}
\newcommand{\adj}[1]{\text{\textopencorner}{#1}\text{\textcorner}}
\newcommand{\comment}[1]{}

% Operators
\def\can{\operatorname{can}}
\def\Hom{\operatorname{Hom}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\nN{\mathds{N}}
\def\nZ{\mathds{Z}}
\def\nQ{\mathds{Q}}
\def\nR{\mathds{R}}
\def\nC{\mathds{C}}
\def\ldot{\,.\,}
\def\FV{\operatorname{FV}}
\def\jac{\operatorname{Jac}_W}
\def\typearrow{\rightarrow}
\def\imp{\supset}

\title{``Assignment" 1}
\author{William Troiani}
\date{September 2022}

\begin{document}

\maketitle

\section{Introduction}
We define a category $\call{L}$ whose objects are the types of simply-typed lambda calculus, and whose morphisms are the terms of that calculus. The natural desiderata for such a category are that the fundamental algebraic structure of lambda calculus, function application and lambda abstraction, should be realised by categorical algebra. 

We assume familiarity with simply-typed lambda calculus; some details are recalled in Appendix \ref{section:intro_lambda} or one can consult \cite{TCR}.





Following Church's original presentation our lambda calculus only contains function types and $\Phi_{\typearrow}$ denotes the set of simple types. We write $\Lambda_\sigma$ for the set of $\alpha$-equivalence classes of lambda terms of type $\sigma$, and we write $=_{\beta\eta}$ for the equivalence relation generated by $\beta\eta$ equivalence.

\begin{definition}[(Category of lambda terms)]\label{definition:lambda_cat} The category $\call{L}$ has objects
	\[
	\operatorname{ob}(\call{L}) = \Phi_{\typearrow} \cup \{ \bold{1} \}
	\]
	and morphisms given for types $\sigma, \tau \in \Phi_{\typearrow}$ by
	\begin{align*}
		\call{L}(\sigma, \tau) &= \Lambda_{\sigma \typearrow \tau}/\!=_{\beta\eta}\,\\
		\call{L}(\bold{1}, \sigma) &= \Lambda_{\sigma}/\!=_{\beta\eta}\,\\
		\call{L}(\sigma, \bold{1}) &= \{ \star \}\,\\
		\call{L}(\bold{1},\bold{1}) &= \{ \star \}\,,
	\end{align*}
	where $\star$ is a new symbol. For $\sigma, \tau, \rho \in \Phi_{\typearrow}$ the composition rule is the function
	\begin{align}
		\label{eq:tttt}\call{L}(\tau, \rho) \times \call{L}(\sigma, \tau) &\longrightarrow \call{L}(\sigma, \rho)\\
		(N,M) &\longmapsto \lambda x^\sigma \ldot (N (M x))
	\end{align}
	where $x \not\in \FV(N) \cup \FV(M)$. We write the composite as $N \circ M$. In the remaining special cases the composite is given by the rules
	\begin{align}
		\label{eq:ttct}\call{L}(\tau, \rho) \times \call{L}(\bold{1}, \tau) \longrightarrow \call{L}(\bold{1}, \rho)\,, \qquad & N \circ M = (N \, M)\,,\\
		\label{eq:ctcc}\call{L}(\bold{1}, \rho) \times \call{L}(\bold{1}, \bold{1}) \longrightarrow \call{L}(\bold{1}, \rho)\,, \qquad & N \circ \star = N\,,\\
		\label{eq:cttc}\call{L}(\bold{1}, \rho) \times \call{L}(\sigma, \bold{1}) \longrightarrow \call{L}(\sigma, \rho)\,, \qquad & N \circ \star = \lambda t^\sigma \ldot N\,,
	\end{align}
	where in the final rule $t \notin \FV(N)$. Notice that these functions, although their rules depend on representatives of equivalence classes, are none-the-less well defined.
\end{definition}

For terms $M,N$ the expression $M = N$ always means equality of terms (that is, up to $\alpha$-equivalence) and we write $M =_{\beta\eta} N$ if we want to indicate equality up to $\beta\eta$-equivalence (for example as morphisms in the category $\call{L}$). Since the free variable set of a lambda term is not invariant under $\beta$-reduction, some care is necessary in defining the category $\call{L}_Q$ below. Let $\twoheadrightarrow_\beta$ denote multi-step $\beta$-reduction \cite[Definition 1.3.3]{sorensen}.

\begin{lemma}\label{lemma:beta_reduce_FV} If $M \twoheadrightarrow_\beta N$ then $\FV(N) \subseteq \FV(M)$.
\end{lemma}
%\begin{proof}
%In a one-step $\beta$-reduction $((\lambda x \ldot P) Q) \rightarrow_\beta P[x:=Q]$ the free variables on the reduced term were either already free in $P$ or $Q$.
%\end{proof}

\begin{definition} Given a term $M$ we define
	\[
	\FV_\beta(M) = \bigcap_{N =_{\beta} M} \FV(N)
	\]
	where the intersection is over all terms $N$ which are $\beta$-equivalent to $M$. 
\end{definition}

Clearly if $M =_{\beta} M'$ then $\FV_\beta(M) = \FV_\beta(M')$.

\begin{lemma}\label{lem:subset} Given terms $M: \sigma \typearrow \rho$ and $N : \sigma$ we have
	\[
	\FV_\beta( (M N) ) \subseteq \FV_\beta(M) \cup \FV_\beta(N)\,.
	\]
\end{lemma}

%The inclusion in the previous lemma may be strict, consider $M = (\lambda a \ldot x)$ and $N = y$ as above. 

\begin{lemma}\label{lemma:comp} Given $M: \sigma \typearrow \rho$ and $N: \tau \typearrow \sigma$ we have
	\be\label{eq:weak_func}
	\FV_\beta( M \circ N ) \subseteq \FV_\beta(M) \cup \FV_\beta(N)\,.
	\ee
\end{lemma}

Given a set $Q$ of variables we write $\Lambda^Q_\sigma$ for the set of lambda terms $M$ of type $\sigma$ with $\operatorname{FV}(M) \subseteq Q$. Let $=_{\beta\eta}$ denote the induced relation on this subset of $\Lambda_\sigma$.

\begin{lemma}\label{lemma:twolambdaQs} For any type $\sigma$ and set $Q$ of variables the image of the injective map
	\be\label{eq:twolambdaQs}
	\Lambda^Q_p/=_{\beta\eta} \longrightarrow \Lambda_p/=_{\beta\eta}
	\ee
	is the set of equivalence classes of terms $M$ with $\operatorname{FV}_\beta(M) \subseteq Q$.
\end{lemma}
\begin{proof}
	Since the simply-typed lambda calculus is strongly normalising \cite[Theorem 3.5.1]{sorensen} and confluent \cite[Theorem 3.6.3]{sorensen} there is a unique normal form $\widehat{M}$ in the $\beta$-equivalence class of $M$, and $\FV_\beta(M) = \FV(\widehat{M})$. Hence if $\operatorname{FV}_\beta(M) \subseteq Q$ then $\operatorname{FV}(\widehat{M}) \subseteq Q$ and so $M$ is in the image of \eqref{eq:twolambdaQs}.
\end{proof}
%\begin{example} For variables $x: \tau$ and $a,y : \sigma$
%\[
%\FV\big( (( \lambda a \ldot x) y) \big) = \{ x, y \} \neq \{ x \} = \FV( x )\,.
%\]
%\end{example}
%\begin{lemma} If .
%\end{lemma}

%\begin{definition} Let $\emph{Var}$ denote the partially ordered set of finite subsets of 
%\[
%Y = \bigcup_{\sigma \in \Phi_{\typearrow}} Y_\sigma\,.
%\]
%At this point we may view $\FV_\beta(-)$ as a function on $\call{L}$, sending morphisms to elements of the partially ordered set $\emph{Var}$ and having a weak functoriality expressed by \eqref{eq:weak_func}. To make sense of this, we adopt the convention that $\FV_\beta(\star) = \emptyset$.
%\end{definition}

%\begin{remark} If we view $\call{L}$ as a $2$-category with only identity $2$-morphisms and $\emph{Var}$ as a $2$-category with one object, and composition of $1$-morphisms (finite subsets of $Y$) as union, then $\FV_\beta$ is a colax functor $\call{L} \longmapsto \emph{Var}$.
%\end{remark}

\begin{definition}\label{definition:lambda_Q} For a set of variables $Q$ we define a subcategory $\call{L}_Q \subseteq \call{L}$ by
	\[
	\operatorname{ob}(\call{L}_Q) = \operatorname{ob}(\call{L}) = \Phi_{\typearrow} \cup \{ \bold{1} \}
	\]
	and for types $\sigma, \rho$
	\begin{align*}
		\call{L}_Q(\sigma, \rho) &= \{ M \in \call{L}(\sigma, \rho) \mid \FV_\beta(M) \subseteq Q \}\,,\\
		\call{L}_Q(\bold{1}, \sigma) &= \{ M \in \call{L}(\bold{1}, \sigma) \mid \FV_\beta(M) \subseteq Q \}\,,\\
		\call{L}_Q(\sigma, \bold{1} ) &= \call{L}(\sigma, \bold{1}) = \{ \star \}\,,\\
		\call{L}_Q(\bold{1}, \bold{1}) &= \call{L}(\bold{1}, \bold{1}) = \{ \star \}\,.
	\end{align*}
	Note that the last two lines have the same form using the convention that $\FV_\beta(\star) = \emptyset$. We denote the inclusion functor by $I_Q: \call{L}_Q \longrightarrow \call{L}$. We write $\call{L}_{cl}$ for $\call{L}_Q$ when $Q = \emptyset$ and call this the category of \textbf{closed} lambda terms.
\end{definition}

We claim that the inclusion $I_Q$ has a right adjoint, provided $Q$ is \textbf{cofinite}, by which we mean that $Q^c = Y \setminus Q$ is a finite set. Our convention is to use letters $\mathfrak{p},\mathfrak{q},\ldots$ for ordered sets of variables, with $\mathfrak{q}$ always denoting an ordering on the finite unordered set of variables $Q^c$. With this notation, we next define a functor
\[
\Gamma_\mathfrak{q}: \call{L} \longrightarrow \call{L}_Q
\]
which we will prove is right adjoint to $I_Q$, with counit a natural transformation
\[
\mathscr{U}^\mathfrak{q}: I_Q \circ \Gamma_\mathfrak{q} \longrightarrow 1_{\call{L}}\,.
\]
For the rest of this section let $Q$ be a cofinite set of variables and $\mathfrak{q} = (q_1: \tau_1, \ldots, t_k:q_k: \tau_k)$ an ordering of the complement. While the functor $\Gamma_\mathfrak{q}$ and natural transformation $\mathscr{U}^\mathfrak{q}$ depend on the choice of ordering, by the uniqueness of adjoints they are independent of the ordering up to unique natural isomorphism.
\begin{definition}\label{definition:gamma} For a type $\rho$ we define
	\[
	\Gamma_{\mathfrak{q}}(\rho) = \tau_1 \typearrow \tau_2 \typearrow \cdots \typearrow \tau_k \typearrow \rho
	\]
	which is $\rho$ if $Q$ is empty. We set $\Gamma_\mathfrak{q}(\bold{1}) = \bold{1}$. For types $\sigma, \tau$ we define a function
	\be
	\Gamma_\mathfrak{q}: \call{L}(\sigma, \tau) \longrightarrow \call{L}_Q(\Gamma_\mathfrak{q} \sigma, \Gamma_\mathfrak{q} \tau)
	\ee
	on a term $M: \sigma \typearrow \tau$ by
	\be\label{eq:gammaqM}
	\Gamma_\mathfrak{q}(M) = \lambda U^{\tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \sigma} q_1^{\tau_1} \cdots q_k^{\tau_k} \ldot \big( M (\cdots (U q_1) \cdots q_k) \big)\,.
	\ee
	Since it is clear by inspection that $\FV_\beta(\Gamma_{\mathfrak{q}} M) \subseteq \FV_\beta(M) \setminus Q^c$ we have $\Gamma_\mathfrak{q} M \in \call{L}_Q$. In the special cases involving $\bold{1}$ we define $\Gamma_\mathfrak{q}$ by
	\begin{align*}
		\call{L}(\sigma, \bold{1}) \longrightarrow \call{L}_Q(\Gamma_\mathfrak{q} \sigma, \Gamma_\mathfrak{q} \bold{1} ) = \call{L}_Q( \Gamma_\mathfrak{q} \sigma, \bold{1} )\,, \qquad &\star \mapsto \star\,\\
		\call{L}(\bold{1}, \rho) \longrightarrow \call{L}_Q(\Gamma_\mathfrak{q} \bold{1}, \Gamma_\mathfrak{q} \rho) = \call{L}_Q( \bold{1}, \Gamma_\mathfrak{q} \rho )\,,\qquad & M \mapsto \lambda q_1^{\tau_1} \cdots q_k^{\tau_k} \ldot M\,\\
		\call{L}(\bold{1}, \bold{1}) \longrightarrow \call{L}_Q(\Gamma_\mathfrak{q} \bold{1}, \Gamma_\mathfrak{q} \bold{1}) = \call{L}_Q(\bold{1}, \bold{1})\,\qquad & \star \mapsto \star\,.
	\end{align*}
\end{definition}
\begin{remark} It is important in \eqref{eq:gammaqM} that we lambda abstract over the particular variables $q_i$ that belong to $Q^c$. By $\alpha$-equivalence the result of a lambda abstraction is independent of the variable we use \emph{if} the term being lambda abstracted does not contain that variable as a free variable. However we are certainly interested in the case where $M$ \emph{does} contain the $q_i$ as free variables, and in these cases $\Gamma_\mathfrak{q}(M)$ defined using, say, a sequence of variables $v_1^{\tau_1},\ldots,v_k^{\tau_k}$ distinct from $\mathfrak{q}$ would be a different morphism in $\call{L}$.
\end{remark}
\begin{lemma}\label{lem:gamfuncto} $\Gamma_\mathfrak{q}$ is a functor $\call{L} \longrightarrow \call{L}_Q$.
\end{lemma}
With the same notation as in Definition \ref{definition:gamma}:
\begin{definition}\label{defn:mathscru} For a type $\rho$ we define $\mathscr{U}^\mathfrak{q}_\rho \in \call{L}( \Gamma_\mathfrak{q} \rho, \rho )$ by
	\be
	\mathscr{U}^\mathfrak{q}_\rho = \lambda U^{\Gamma_\mathfrak{q} \rho} \ldot ( \cdots (( U q_1 ) q_2) \cdots q_k)\,.
	\ee
	Once again, it is significant that we use the sequence of variables $\mathfrak{q}$ to form this term, and not arbitrary variables of the same type. The special case is $\mathscr{U}^\mathfrak{q}_\bold{1} \in \call{L}(\Gamma_\mathfrak{q} \bold{1}, \bold{1}) = \call{L}(\bold{1}, \bold{1})$ given by $\mathscr{U}^\mathfrak{q}_\bold{1} = \star$.
\end{definition}

\begin{proposition} Given types $\tau_1,\ldots,\tau_k,\sigma,\rho$ and a permutation $\theta \in S_k$, the term
	\begin{gather*}
		P_\theta: \big( \tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho \big) \typearrow \big( \tau_{\theta(1)} \typearrow \cdots \typearrow \tau_{\theta(k)} \typearrow \rho \big)\\
		P_\theta = \lambda U^{\tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho} v_1^{\tau_{\theta(1)}}v_2^{\tau_{\theta(2)}} \cdots v_k^{\tau_{\theta(k)}} \ldot \big (\cdots((U v_{\theta^{-1}(1)} ) v_{\theta^{-1}(2)}) \cdots v_{\theta^{-1}(k)}\big)
	\end{gather*}
	is an isomorphism in $\cat{L}$ between the objects
	\[
	\big( \tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho \big) \cong \big( \tau_{\theta(1)} \typearrow \cdots \typearrow \tau_{\theta(k)} \typearrow \rho \big)\,.
	\]
\end{proposition}
With the notation of the proposition:
\begin{corollary}\label{cor:perm} There is a bijection
	\[
	\xymatrix@C+2pc{
		\Lambda_{\tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho} /\!=_{\beta\eta} \ar[r]^-{\cong} & \Lambda_{\tau_{\theta(1)} \typearrow \cdots \typearrow \tau_{\theta(k)} \typearrow \rho} /\!=_{\beta\eta}\,.
	}
	\]
\end{corollary}
\begin{proof}
	We have, by the proposition
	\begin{align*}
		\Lambda_{\tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho} /\!=_{\beta\eta} &= \call{L}(\bold{1}, \tau_1 \typearrow \cdots \typearrow \tau_k \typearrow \rho)\\
		&\cong \cat{L}(\bold{1}, \tau_{\theta(1)} \typearrow \cdots \typearrow \tau_{\theta(k)} \typearrow \rho)\\
		&= \Lambda_{\tau_{\theta(1)} \typearrow \cdots \typearrow \tau_{\theta(k)} \typearrow \rho} /\!=_{\beta\eta}\,.
	\end{align*}
\end{proof}

\subsection{Structural rules and monads}\label{section:monads}
As above, let $\call{L}_{cl}$ denote the category of closed lambda terms. Throughout this section, $A \subseteq Y$ is finite and so there is a right adjoint $\Gamma_{\mathfrak{a}}$ to the inclusion $I$ for any ordering $\mathfrak{a}$ of $A$:
\be
\xymatrix@C+2pc{
	\call{L}_{cl} \ar@<1ex>[r]^-{I} & \call{L}_A \ar@<1ex>[l]^-{\Gamma_{\mathfrak{a}}}
}\,.
\ee
\begin{definition}\label{def:T_monad} Denote by $T_\mathfrak{a}$ the composition $\Gamma_\mathfrak{a} \circ I$ on $\call{L}_{cl}$.
\end{definition}
In the case where $\mathfrak{a} = \{x:\alpha\}$ we define the monad $T_\mathfrak{a}$ to have multiplication $\mu$ given by
$$\mu_{\sigma} = \lambda u^{\alpha \typearrow (\alpha \typearrow \sigma)}x^\alpha. ((ux)x) : (\alpha \typearrow (\alpha \typearrow \sigma)) \typearrow (\alpha \typearrow \sigma)$$
and unit $\xi$ given by
$$\xi_{\sigma} =  \lambda w^\sigma x^\alpha.w: \sigma \typearrow (\alpha \typearrow \sigma)\,.$$
Let $\mathfrak{a},\mathfrak{b}$ be \emph{disjoint} finite ordered sets of variables, and $T_\mathfrak{a}, T_\mathfrak{b}$ the associated monads on $\call{L}_{cl}$. There is a distributive law between these two monads, and their composition as functors is therefore naturally equipped with the structure of a monad. For simplicity, we write down the propositions only in the case where $\mathfrak{a} = \{ x : \alpha \}$ and $\mathfrak{b} = \{ y : \beta \}$ are singletons.
\begin{lemma}\label{lem:distlawlambda}
	With the induced monad structure the composite $T_\mathfrak{a} T_\mathfrak{b}$ is isomorphic, as a monad, to $T_{\mathfrak{a} : \mathfrak{b}}$ where $\mathfrak{a} : \mathfrak{b}$ denotes concatenation of sequences.
\end{lemma}

\section{Questions}
\begin{question}
	Prove Lemma \ref{lem:subset}, you may use Lemma \ref{lemma:beta_reduce_FV} in your proof.
\end{question}

\begin{question}
	Prove that $\mathscr{U}^\mathfrak{q}$ is a natural transformation $I_Q \circ \Gamma_\mathfrak{q} \longrightarrow 1_{\call{L}}$ in the special case where $\mathfrak{q} = \{ q: \tau \}$.
\end{question}

\subsection{Extension questions (requires adjoints and monads)}

\begin{question}
	Prove that $\Gamma_{\frak{q}}$ is right adjoint to $I_Q$ with counit $\scr{U}^{\frak{q}}$ by showing that for types $\sigma, \rho$ there are natural bijections
	\begin{gather}
		\call{L}( \sigma, \rho ) = \call{L}( I_Q( \sigma ), \rho ) \cong \call{L}_Q( \sigma, \Gamma_\mathfrak{q} \rho )\,,\label{eq:adjun_1}\\
		\call{L}( \bold{1}, \rho ) = \call{L}( I_Q( \bold{1} ), \rho ) \cong \call{L}_Q( \bold{1}, \Gamma_\mathfrak{q} \rho )\,.\label{eq:adjun_2}
	\end{gather}
	You can use Corollary \ref{cor:perm} in your proof.
\end{question}

\begin{question}
	Prove that the monads $T_{\mathfrak{a}}, T_\mathfrak{b}$ admit a distributive law
	\begin{gather*}
		\chi: T_\mathfrak{a} T_\mathfrak{b} \longrightarrow T_\mathfrak{b}T_\mathfrak{a}\,\\
		\chi_{\sigma} = \lambda z^{\alpha \typearrow (\beta \typearrow \sigma)} y^\beta x^\alpha.((zx)y)\,.
	\end{gather*}
\end{question}

\appendix

\section{Background on lambda calculus}\label{section:intro_lambda}
% For each type $\sigma$ there is a countable set $Y_\sigma$ of variables of type $\sigma$, and if $\sigma \neq \tau$ then $Y_\sigma \cap Y_\tau = \emptyset$. We write $x: \sigma$ for $x \in Y_{\sigma}$. 

\begin{defn}
	\label{lambdacalc}
	Let $\scr{V}$ be a (countably) infinite set of variables, and let $\scr{L}$ be the language consisting of $\scr{V}$ along with the special symbols 
	\[\lambda \qquad . \qquad ( \qquad )\]
	Let $\scr{L}^\ast$ be the set of words of $\scr{L}$, more precisely, an element $w \in \scr{L}^\ast$ is a finite sequence $(w_1,...,w_n)$ where each $w_i$ is in $\scr{L}$, for convenience, such an element will be written as $w_1...w_n$. Now let $\Lambda'$ denote the smallest subset of $\scr{L}^\ast$ such that
	\begin{itemize}
		\item if $x \in \scr{V}$ then $x \in \Lambda'$,
		\item if $M,N \in \Lambda'$ then $(MN) \in \Lambda'$,
		\item if $x \in \scr{V}$ and $M \in \Lambda'$ then $(\lambda x. M) \in \Lambda'$
	\end{itemize}
	$\Lambda'$ is the set of \textbf{preterms}. A preterm $M$ such that $M \in \scr{V}$ is a \textbf{variable}, if $M = (M_1M_2)$ for some preterms $M_1,M_2$, then $M$ is an \textbf{application}, and if $M = (\lambda x, M')$ for some $x \in \scr{V}$ and $M' \in \Lambda'$ then $M$ is an \textbf{abstraction}.
\end{defn}

\begin{defn}
	\textbf{Single step $\beta$-reduction} $\to_\beta$ is the smallest relation on $\Lambda$ satisfying:
	\begin{itemize}
		\item the \textbf{reduction axiom}:
		\begin{itemize}
			\item for all variables $x$ and $\lambda$-terms $M,M'$, $(\lambda x. M)M' \to_\beta M[x := M']$, where $M[x:= M']$ is the term given by replacing every free occurrence of $x$ in $M$ with $M'$,
		\end{itemize}
		\item the following \textbf{compatibility axioms}:
		\begin{itemize}
			\item if $M \to_\beta M'$ then $(MN) \to_\beta (M'N)$ and $(NM) \to_\beta (NM')$,
			\item if $M \to_\beta M'$ then for any variable $x$, $\lambda x. M \to_\beta \lambda x M'$.
		\end{itemize}
	\end{itemize}
	A subterm of the form $(\lambda x. M)M'$ is a \textbf{$\beta$-redex}, and $(\lambda x. M)M'$ \textbf{single step $\beta$-reduces} to $M'$.
\end{defn}

\begin{defn}\label{def:beta}
	\textbf{Multi step $\beta$-reduction} $\twoheadrightarrow$ (or simply \textbf{$\beta$-reduction}) is the smallest relation on $\Lambda$ satisfying
	\begin{itemize}
		\item the \textbf{reduction axiom}:
		\begin{itemize}
			\item if $M \to_\beta M'$ then $M \twoheadrightarrow M'$,
		\end{itemize}
		\item \textbf{reflexivity}:
		\begin{itemize}
			\item if $M = M'$ then $M \twoheadrightarrow M'$,
		\end{itemize}
		\item \textbf{transitivity}:
		\begin{itemize}
			\item if $M_1 \twoheadrightarrow M_2$ and $M_2 \twoheadrightarrow M_3$ then $M_1 \twoheadrightarrow M_3$
		\end{itemize}
	\end{itemize}
	If $M \twoheadrightarrow M'$, then $M$ \textbf{multistep $\beta$-reduces} to $M[x := M']$.
	
	The reflexive, symmetric closure of multistep $\beta$-reduction is \textbf{$\beta$-equivalence}. That is, the smallest relation containing multi step $\beta$-reduction which is reflexive and symmetric.
\end{defn}

There is also $\eta$-expansion, which is defined similarly, we are more terse in Definition \ref{def:eta} than in Definition \ref{def:beta}.

\begin{defn}\label{def:eta}
	\textbf{Single step $\eta$-expansion} $\lto_\eta$ is the smallest, compatible relation on $\Lambda$ satisfying:
	\begin{equation}
		M \lto_\eta \lambda x. Mx
	\end{equation}
	where $x$ is a variable not in the free variable set of $M$. \textbf{Multi step $\eta$-expansion} is the reflexive closure of single step $\eta$-expansion. \textbf{$\eta$-equivalence} is the reflexive, symmetric symmetric closure of multi step $\eta$-expansion.
	
	\textbf{$\beta\eta$-equivalence} is the union of $\eta$-equivalence and $\beta$-equivalence.
\end{defn}

In the simply-typed lambda calculus \cite[Chapter 3]{sorensen} there is an infinite set of \textbf{atomic types} and the set $\Phi_{\typearrow}$ of \textbf{simple types} is built up from the atomic types using $\typearrow$. Let $\Lambda'$ denote the set of untyped lambda calculus preterms in these variables, as defined in \cite[Chapter 1]{sorensen}. We define a subset $\Lambda'_{wt} \subseteq \Lambda'$ of \textbf{well-typed} preterms, together with a function $t: \Lambda'_{wt} \longrightarrow \Phi_{\typearrow}$ by induction:
\begin{itemize}
	\item all variables $x : \sigma$ are well-typed and $t(x) = \sigma$,
	\item if $M = (P \, Q)$ and $P,Q$ are well-typed with $t(P) = \sigma \typearrow \tau$ and $t(Q) = \sigma$ for some $\sigma, \tau$ then $M$ is well-typed and $t(M) = \tau$,
	\item if $M = \lambda x\ldot N$ with $N$ well-typed, then $M$ is well-typed and $T(M) = t(x) \typearrow t(N)$.
\end{itemize}
We define $\Lambda'_\sigma = \{ M \in \Lambda'_{wt} \l t(M) = \sigma \}$ and call these \textbf{preterms of type $\sigma$}. Next we observe that $\Lambda'_{wt} \subseteq \Lambda'$ is closed under the relation of $\alpha$-equivalence on $\Lambda'$, as long as we understand $\alpha$-equivalence type by type, that is, we take
\[
\lambda x \ldot M =_\alpha \lambda y\ldot M[x := y]
\]
as long as $t(x) = t(y)$. Denoting this relation by $=_\alpha$, we may therefore define the sets of \textbf{well-typed lambda terms} and \textbf{well-typed lambda terms of type $\sigma$}, respectively:
\begin{align}
	\Lambda_{wt} &= \Lambda'_{wt} / =_\alpha\,\\
	\Lambda_\sigma &= \Lambda'_\sigma / =_\alpha\,.
\end{align}
Note that $\Lambda_{wt}$ is the disjoint union over all $\sigma \in \Phi_{\typearrow}$ of $\Lambda_\sigma$. We write $M: \sigma$ as a synonym for $[M] \in \Lambda_\sigma$, and call these equivalence classes \textbf{terms of type $\sigma$}. Since terms are, by definition, $\alpha$-equivalence classes, the expression $M = N$ henceforth means $M =_\alpha N$ unless indicated otherwise. We denote the set of free variables of a term $M$ by $\FV(M)$.

%We briefly recall the definition of $\beta$ and $\eta$ equivalence, for which see \cite[Chapter 3]{sorensen}. The equivalence relation $=_\beta$ on $\Lambda_\sigma$ is generated by one-step $\beta$-reductions of the form
%\be
%((\lambda x \,. \, M) N) \longrightarrow_\beta M[ x:= N ]
%\ee
%where $N, x: \sigma$ and $M: \sigma \typearrow \tau$. The equivalence relation $=_\eta$ on $\Lambda_\sigma$ is generated by
%\be
%\lambda x \ldot (M x) =_\eta M
%\ee
%for any $x \notin \FV(M), x : \sigma, M : \sigma \typearrow \tau$.

\begin{definition}\label{defn:subst} The substitution operation on lambda terms is a family of functions
	\[
	\big\{ \operatorname{subst}_\sigma: Y_\sigma \times \Lambda_{\sigma} \times \Lambda_{wt} \longrightarrow \Lambda_{wt} \big\}_{\sigma \in \Phi_{\rightarrow}} \]
	We write $M[ x:= N ]$ for $\operatorname{subst}_\sigma( x, N, M )$ and this term is defined inductively (on the structure of $M$) as follows:
	\begin{itemize}
		%  \item if $x \not\in \operatorname{FV}(M)$ then $M[x:= N] = M$,
		\item if $M$ is a variable then either $M = x$ in which case $M[x := N] = N$, or $M \neq x$ in which case $M[ x:= N ] = M$.
		\item if $M = (M_1 \, M_2)$ then $M[x := N] = \big(M_1[x:= N] \, M_2[x := N]\big)$.
		\item if $M = \lambda y. L$ we may assume by $\alpha$-equivalence that $y \neq x$ and that $y$ does not occur in $N$ and set $M[x := N] = \lambda y. L[ x := N ]$. %That this choice of $y'$ still yields a well defined function follows from $\alpha$-equivalence.
	\end{itemize}
	Note that if $x \notin \operatorname{FV}(M)$ then $M[ x:= N] = M$.
\end{definition}

\begin{thebibliography}{9}
	\bibitem{sorensen}
	M.~S\o rensen and P.~Urzyczyn, \textsl{Lectures on the Curry-Howard isomorphism}, Studies in Logic and the Foundations of Mathematics Vol. 149, Elsevier New York, (2006).
	
	\bibitem{TCR} W. Troiani, \textsl{An Introduction to the Untyped $\lambda$-Calculus and the Church-Rosser Theorem}, \url{https://williamtroiani.github.io/pdfs/ChurchRosserTheorem.pdf}
	
\end{thebibliography}

\end{document}
